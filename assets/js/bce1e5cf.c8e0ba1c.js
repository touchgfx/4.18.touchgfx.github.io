"use strict";(self.webpackChunktouchgfx_documentation=self.webpackChunktouchgfx_documentation||[]).push([[3413],{3905:function(e,t,n){n.d(t,{Zo:function(){return s},kt:function(){return m}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var d=a.createContext({}),c=function(e){var t=a.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},s=function(e){var t=c(e.components);return a.createElement(d.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,m=p["".concat(d,".").concat(h)]||p[h]||u[h]||o;return n?a.createElement(m,i(i({ref:t},s),{},{components:n})):a.createElement(m,i({ref:t},s))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l[p]="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},70814:function(e,t,n){var a=n(67294),r=n(88678);const o=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},a.createElement("path",{"fill-rule":"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}));class i extends a.Component{render(){return a.createElement(r.Z,{color:"var(--highlight-color-caution)",header:"Caution",type:"caution",icon:o},this.props.children)}}t.Z=i},22425:function(e,t,n){var a=n(67294);class r extends a.Component{render(){return a.createElement("div",{class:"code-header"},a.createElement("div",null,a.createElement("h5",null,this.props.children)))}}t.Z=r},44035:function(e,t,n){var a=n(67294),r=n(25026);t.Z=function(e){const t=e.noShadow||!1,n=e.width,o=e.height,i=(0,r.Z)(e.imageSource);return t?a.createElement("div",{class:"figure noshadow"},a.createElement("a",{href:i,target:"_blank"},a.createElement("img",{width:n,height:o,src:i})),a.createElement("p",null,e.children)):a.createElement("div",{class:"figure"},a.createElement("a",{href:i,target:"_blank"},a.createElement("img",{width:n,height:o,src:i})),a.createElement("p",null,e.children))}},29415:function(e,t,n){var a=n(67294),r=n(88678);const o=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{"fill-rule":"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}));class i extends a.Component{render(){return a.createElement(r.Z,{color:"var(--highlight-color-further-reading)",header:"Further reading",type:"further-reading",icon:o},this.props.children)}}t.Z=i},88678:function(e,t,n){var a=n(67294);class r extends a.Component{render(){const e=`highlight highlight-${this.props.type}`;return a.createElement("div",{class:e},a.createElement("div",{class:"highlight-heading"},a.createElement("h5",null,a.createElement("div",{class:"highlight-icon"},this.props.icon),this.props.header)),a.createElement("div",{class:"highlight-content"},this.props.children))}}t.Z=r},93054:function(e,t,n){var a=n(67294),r=n(88678);const o=a.createElement("svg",{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},a.createElement("path",{"fill-rule":"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}));class i extends a.Component{render(){return a.createElement(r.Z,{color:"var(--highlight-color-note)",header:"Note",type:"note",icon:o},this.props.children)}}t.Z=i},93259:function(e,t,n){n.r(t),n.d(t,{assets:function(){return w},contentTitle:function(){return T},default:function(){return C},frontMatter:function(){return b},metadata:function(){return v},toc:function(){return y}});var a=n(3905),r=n(44035),o=n(93054),i=n(29415),l=n(22425),d=n(70814),c=n(39130),s=Object.defineProperty,p=Object.defineProperties,u=Object.getOwnPropertyDescriptors,h=Object.getOwnPropertySymbols,m=Object.prototype.hasOwnProperty,f=Object.prototype.propertyIsEnumerable,g=(e,t,n)=>t in e?s(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,k=(e,t)=>{for(var n in t||(t={}))m.call(t,n)&&g(e,n,t[n]);if(h)for(var n of h(t))f.call(t,n)&&g(e,n,t[n]);return e};const b={id:"touchgfx-generator",title:"Generator User Guide"},T=void 0,v={unversionedId:"development/touchgfx-hal-development/touchgfx-generator",id:"development/touchgfx-hal-development/touchgfx-generator",title:"Generator User Guide",description:"",source:"@site/docs/development/touchgfx-hal-development/touchgfx-generator.mdx",sourceDirName:"development/touchgfx-hal-development",slug:"/development/touchgfx-hal-development/touchgfx-generator",permalink:"/4.18/docs/development/touchgfx-hal-development/touchgfx-generator",draft:!1,tags:[],version:"current",frontMatter:{id:"touchgfx-generator",title:"Generator User Guide"},sidebar:"docs",previous:{title:"Abstraction Layer Architecture",permalink:"/4.18/docs/development/touchgfx-hal-development/touchgfx-architecture"},next:{title:"LTDC/Parallel RGB",permalink:"/4.18/docs/development/touchgfx-hal-development/scenarios/scenarios-ltdc-parallel-rgb"}},w={},y=[{value:"Enabling TouchGFX Generator",id:"enabling-touchgfx-generator",level:2},{value:"Generated Code Architecture",id:"generated-code-architecture",level:2},{value:"Feature Overview",id:"feature-overview",level:2},{value:"Display",id:"display",level:2},{value:"Interface and dimensions",id:"interface-and-dimensions",level:3},{value:"Framebuffer Pixel Format",id:"framebuffer-pixel-format",level:3},{value:"Buffering Strategies",id:"buffering-strategies",level:3},{value:"Driver",id:"driver",level:2},{value:"Application Tick Source",id:"application-tick-source",level:3},{value:"Graphics Accelerator",id:"graphics-accelerator",level:3},{value:"Real-Time Operating System",id:"real-time-operating-system",level:3},{value:"Other CMSIS compliant OS",id:"other-cmsis-compliant-os",level:4},{value:"Additional features",id:"additional-features",level:3},{value:"External Data Reader",id:"external-data-reader",level:4},{value:"8bit LTDC Color Look-up Table",id:"8bit-ltdc-color-look-up-table",level:4},{value:"Video Decoding",id:"video-decoding",level:2},{value:"Type",id:"video-decoding-type",level:3},{value:"Concurrent videos",id:"video-decoding-number",level:3},{value:"Strategy",id:"video-decoding-strategy",level:3},{value:"Decode Format",id:"decode-format",level:3},{value:"Buffer size",id:"video-decoding-buffer-size",level:3},{value:"Generated project",id:"generated-project",level:2},{value:"TouchGFX Designer Project",id:"touchgfx-designer-project",level:2},{value:"Modifying Generated Behavior",id:"modifying-generated-behavior",level:2},{value:"Upgrading Projects",id:"upgrading-projects",level:2}],G={toc:y};function C(e){var t,n=e,{components:s}=n,g=((e,t)=>{var n={};for(var a in e)m.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&h)for(var a of h(e))t.indexOf(a)<0&&f.call(e,a)&&(n[a]=e[a]);return n})(n,["components"]);return(0,a.kt)("wrapper",(t=k(k({},G),g),p(t,u({components:s,mdxType:"MDXLayout"}))),(0,a.kt)("p",null,"TouchGFX Generator, a part of X-CUBE-TOUCHGFX, is a STM32CubeMX Additional-Software component that helps developers configure TouchGFX to run on their hardware platform. Based on existing STM32CubeMX settings and user input TouchGFX Generator will generate the files required to configure a working TouchGFX application. They include files for TouchGFX HAL, TouchGFX OSAL and TouchGFX Configuration."),(0,a.kt)("p",null,"Once code is generated through STM32CubeMX, the TouchGFX project can be opened through TouchGFX Designer where the UI is developed. TouchGFX Designer automatically adds any additional generated code files to the target IDE project that was configured for the project in STM32CubeMX."),(0,a.kt)("h2",k({},{id:"enabling-touchgfx-generator"}),"Enabling TouchGFX Generator"),(0,a.kt)("p",null,'Users gain access to adding functionality from X-CUBEs by pressing the "Select Components" button.'),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/enable-generator.webp",mdxType:"Figure"},"Selecting Additional Software in STM32CubeMX"),(0,a.kt)("p",null,"The following figure shows how TouchGFX Generator can be enabled for a project:"),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/add-generator-v4.17.webp",width:"580",mdxType:"Figure"},"Enabling TouchGFX Generator"),(0,a.kt)("p",null,"If enabling TouchGFX for a Dual-Core MCU, be sure to enable for the the correct context. TouchGFX can only be enabled for a single context:"),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/add-generator-dual-core-v4.17.webp",mdxType:"Figure"},"Enabling TouchGFX Generator for Dual Core"),(0,a.kt)("h2",k({},{id:"generated-code-architecture"}),"Generated Code Architecture"),(0,a.kt)("p",null,"Before describing the features of TouchGFX Generator it is important to understand the architecture of the generated code and how developers can use it to customize configuration and behavior."),(0,a.kt)("p",null,"Handwritten user code in files generated by STM32CubeMX is protected through the use of ",(0,a.kt)("strong",{parentName:"p"},"User Code")," sections placed strategically throughout the code generated by STM32CubeMX (C code).\xa0In the code generated by TouchGFX Generator (C++ code) this flexibility is accomplished through inheritance."),(0,a.kt)("p",null,"When TouchGFX Generator is added through ",(0,a.kt)("em",{parentName:"p"},"Additional Software")," and enabled, STM32CubeMX will always create a ",(0,a.kt)("em",{parentName:"p"},"TouchGFX")," folder for the project. The folder always contains the same files, regardless of configuration, while the content of the files changes according to STM32CubeMX and User configuration."),(0,a.kt)("p",null,"The listing below shows an overview of the content of a STM32CubeMX project with TouchGFX Generator ",(0,a.kt)("em",{parentName:"p"},"enabled"),", with emphasis on TouchGFX related files. The table following the list outlines the responsibility of the most important entries."),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFX Folder"),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{}),"\u2502   .mxproject\n\u2502   myproject.ioc\n\u251c\u2500\u2500\u2500Core\n\u251c\u2500\u2500\u2500Drivers\n\u251c\u2500\u2500\u2500EWARM\n\u251c\u2500\u2500\u2500Middlewares\n\u2514\u2500\u2500\u2500TouchGFX\n    \u2502   ApplicationTemplate.touchgfx.part\n    \u251c\u2500\u2500\u2500App\n    \u2502       app_touchgfx.c\n    \u2502       app_touchgfx.h\n    \u2514\u2500\u2500\u2500target\n        \u2502   STM32TouchController.cpp\n        \u2502   STM32TouchController.hpp\n        \u2502   TouchGFXGPIO.cpp\n        \u2502   TouchGFXHAL.cpp\n        \u2502   TouchGFXHAL.hpp\n        \u2502\n        \u2514\u2500\u2500\u2500generated\n                OSWrappers.cpp\n                TouchGFXConfiguration.cpp\n                TouchGFXGeneratedHAL.cpp\n                TouchGFXGeneratedHAL.hpp\n")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",k({parentName:"tr"},{align:null}),"Folder"),(0,a.kt)("th",k({parentName:"tr"},{align:null}),"Responsibility"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",k({parentName:"tr"},{align:null}),"myproject.ioc"),(0,a.kt)("td",k({parentName:"tr"},{align:null}),"STM32CubeMX Project file")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",k({parentName:"tr"},{align:null}),"Core"),(0,a.kt)("td",k({parentName:"tr"},{align:null}),(0,a.kt)("inlineCode",{parentName:"td"},"main.c")," and startup code")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",k({parentName:"tr"},{align:null}),"Drivers"),(0,a.kt)("td",k({parentName:"tr"},{align:null}),"CMSIS and MCU family drivers")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",k({parentName:"tr"},{align:null}),"EWARM"),(0,a.kt)("td",k({parentName:"tr"},{align:null}),"IDE project folder. Can be EWARM, MDK-ARM or STM32CubeIDE")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",k({parentName:"tr"},{align:null}),"Middlewares"),(0,a.kt)("td",k({parentName:"tr"},{align:null}),"Contains TouchGFX library/headerfiles and third party software like FreeRTOS.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",k({parentName:"tr"},{align:null}),"ApplicationTemplate.touchgfx.part"),(0,a.kt)("td",k({parentName:"tr"},{align:null}),"The .part file is updated by STM32CubeMX with information that is relevant to TouchGFX Designer project, e.g. screen dimensions and bit depth")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",k({parentName:"tr"},{align:null}),"App"),(0,a.kt)("td",k({parentName:"tr"},{align:null}),"X-CUBE interface to STM32CubeMX. ",(0,a.kt)("inlineCode",{parentName:"td"},"app_touchgfx.c")," contains definitions for the functions ",(0,a.kt)("inlineCode",{parentName:"td"},"MX_TouchGFX_Process(void)")," and ",(0,a.kt)("inlineCode",{parentName:"td"},"MX_TouchGFX_Init(void)")," which are used to initialize TouchGFX and start its main loop.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",k({parentName:"tr"},{align:null}),"target/generated"),(0,a.kt)("td",k({parentName:"tr"},{align:null}),"This sub-folder contains the read-only files that get overwritten by STM32CubeMX when configurations change. ",(0,a.kt)("inlineCode",{parentName:"td"},"TouchGFXGeneratedHAL.cpp")," is a sub-class of the TouchGFX class ",(0,a.kt)("inlineCode",{parentName:"td"},"HAL")," and contains the code that STM32CubeMX can generate based on its current configuration. ",(0,a.kt)("inlineCode",{parentName:"td"},"OSWrappers.cpp")," (The OSAL) contains the functions required to synchronize with TouchGFX Engine, and finally ",(0,a.kt)("inlineCode",{parentName:"td"},"TouchGFXConfiguration.cpp")," which contains the code to construct and configure TouchGFX, including the HAL.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",k({parentName:"tr"},{align:null}),"target"),(0,a.kt)("td",k({parentName:"tr"},{align:null}),"Contains the bulk of files that can be modified by the user to extend the behavior of the HAL or to override configurations generated by STM32CubeMX. ",(0,a.kt)("inlineCode",{parentName:"td"},"STM32TouchController.cpp")," contains an empty touch controller interface. ",(0,a.kt)("inlineCode",{parentName:"td"},"TouchGFXHAL.cpp")," defines a sub-class, ",(0,a.kt)("inlineCode",{parentName:"td"},"TouchGFXHAL"),", of ",(0,a.kt)("inlineCode",{parentName:"td"},"TouchGFXGeneratedHAL"),".")))),(0,a.kt)("p",null,"It is important to know that ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXConfiguration.cpp")," contains a function that constructs the HAL and a function that starts the main loop of TouchGFX. Additional configuration can be done in the editable user-class ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL"),". The general architecture of the HAL is seen below:"),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/code-architecture.webp",noShadow:!0,width:"200",mdxType:"Figure"},"Hierarchy of generated code"),(0,a.kt)("h2",k({},{id:"feature-overview"}),"Feature Overview"),(0,a.kt)("p",null,"Having enabled TouchGFX Generator, four groups exist in the user interface:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("em",{parentName:"strong"},"Dependencies"))," - This group contains notifications to the developer about dependencies, warnings or concrete errors in the configuration. The group is hidden if no entries exist."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("em",{parentName:"strong"},"Display"))," - This group contains settings related to display such as interface, framebuffer bitdepth, width and height. These settings directly impact the size of the canvas of the TouchGFX project as well as the code generated for assets."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("em",{parentName:"strong"},"Driver"))," - This group allows the user to opt-in for a number of ready-made drivers related to the tick source of the application, graphics acceleration and RTOS. Since STM32CubeMX supports FreeRTOS (CMSIS RTOS v1 and v2) configurations, TouchGFX Generator provides drivers for each of these options."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},(0,a.kt)("em",{parentName:"strong"},"Video Decoding"))," - This group allows the user to enable hardware or software video decoding. This option is necessary to work with the video widget. Note that not all MCUs support video decoding.")),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/four-sections.webp",width:"600",mdxType:"Figure"},"TouchGFX Generator has four groups: Dependencies, Display, Driver and Video Decoding"),(0,a.kt)("h2",k({},{id:"display"}),"Display"),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"Display")," group contains configurations related to display, such as interface, dimensions and buffering strategies."),(0,a.kt)("h3",k({},{id:"interface-and-dimensions"}),"Interface and dimensions"),(0,a.kt)("p",null,"Multiple display interfaces are usable today with STM32 microcontrollers, e.g.:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Parallel RGB (LTDC)"),(0,a.kt)("li",{parentName:"ul"},"MIPI DSI"),(0,a.kt)("li",{parentName:"ul"},"FMC"),(0,a.kt)("li",{parentName:"ul"},"SPI")),(0,a.kt)("p",null,"In the case of MCUs with a display connected to an LTDC or FMC ",(0,a.kt)("em",{parentName:"p"},"TouchGFX Generator")," can generate code to transfer the framebuffer to the connected display. For DSI and SPI interfaces drivers must be implemented by developers themselves."),(0,a.kt)(i.Z,{mdxType:"FurtherReading"},"See section ",(0,a.kt)(c.Z,{to:"scenarios/scenarios-ltdc-parallel-rgb",mdxType:"Link"},"Scenarios")," for concrete examples of code for different display interfaces."),(0,a.kt)("h3",k({},{id:"framebuffer-pixel-format"}),"Framebuffer Pixel Format"),(0,a.kt)("p",null,'The following framebuffer pixel formats are currently supported by TouchGFX Generator. All options are available when using "Custom" display interface, otherwise options are restricted to display controller settings (e.g. configuring the LTDC Framebuffer format to "RGB565" will limit the options to "RGB565" in TouchGFX Generator).'),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"BW (1bpp)"),(0,a.kt)("li",{parentName:"ol"},"Grey2 (2bpp)"),(0,a.kt)("li",{parentName:"ol"},"Grey4 (4bpp)"),(0,a.kt)("li",{parentName:"ol"},"ABRG2222 (8bpp)"),(0,a.kt)("li",{parentName:"ol"},"ARGB2222 (8bpp)"),(0,a.kt)("li",{parentName:"ol"},"BGRA2222 (8bpp)"),(0,a.kt)("li",{parentName:"ol"},"RGBA2222 (8bpp)"),(0,a.kt)("li",{parentName:"ol"},"RGB565 (16bpp)"),(0,a.kt)("li",{parentName:"ol"},"RGB888 (24bpp)"),(0,a.kt)("li",{parentName:"ol"},"ARGB8888 (32bpp)"),(0,a.kt)("li",{parentName:"ol"},"XRGB8888 (32bpp)")),(0,a.kt)(o.Z,{mdxType:"Note"},"Some pixel formats have no- or only partial ChromART (DMA2D) support."),(0,a.kt)(d.Z,{mdxType:"Caution"},(0,a.kt)("b",null,"For Cortex F7/H7"),": If the framebuffer is placed in Write Through cached memory (e.g. SRAM) then the DCache is flushed by the generated code prior to DMA2D (if configured in the Generator) accessing it. Remember to enable ",(0,a.kt)("b",null,"CPU Cache")," in the ",(0,a.kt)("b",null,"System Core")," settings for ",(0,a.kt)("b",null,"Cortex M7")," in STM32CubeMX in order for this caching mechanic to work."),(0,a.kt)(i.Z,{mdxType:"FurtherReading"},"See the ",(0,a.kt)(c.Z,{to:"../board-bring-up/how-to/02-cpu-running#cache-on-f7-and-h7",mdxType:"Link"},"Cache on F7 and H7")," subsection for more information about CPU caching."),(0,a.kt)("h3",k({},{id:"buffering-strategies"}),"Buffering Strategies"),(0,a.kt)("p",null,"The following frame buffer strategies can be configured through TouchGFX generator:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Single Buffer"),' - Use only one application frame buffer. Possibly limits performance but uses less memory. Can be used with the "Buffer Location" configuration to place it in internal RAM. For further optimization the user can define a function that returns the current line being processed by the display controller. This method is used by the framework to allow updates to memory that has already been transferred to the display during this frame.'),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Double Buffer")," - Use two frame buffers. Usually allows for better performance at the cost of memory."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Partial Buffer")," - Use one or more user defined chunks of memory as the frame buffer. This strategy is targeted at low cost solutions that do not rely on external RAM, but have displays for which a full frame buffer would exceed available memory.")),(0,a.kt)("p",null,'In the case of Single Buffer and Double Buffer users are allowed to configure their location through the "Buffer Location" configuration which offers the following options:'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"By Allocation")," - Lets the linker place frame buffer memory according to linker script. Default is in internal RAM."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"By Address")," - Allows the user to define one (Single) or two (Double) frame buffer addresses.")),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Partial Buffer")," strategy allows the user to define the following parameters:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Number of blocks (always placed in internal RAM)"),(0,a.kt)("li",{parentName:"ul"},"Block size (bytes)")),(0,a.kt)("p",null,"To understand some core concepts regarding the Partial Buffer strategy please read the ",(0,a.kt)("a",k({parentName:"p"},{href:"../scenarios/lowering-memory-usage-with-partial-framebuffer"}),"dedicated article")," on Lowering Memory requirements using partial Frame Buffers. The article shows, conceptually, how to achieve partial frame buffers and the code shown in this article will differ slightly from what is generated by TouchGFX Generator.\nPlease see ",(0,a.kt)("a",k({parentName:"p"},{href:"scenarios/scenarios-framebuffer-strategies"}),"Frame Buffer Strategies")," for concrete examples of the generated code for these strategies."),(0,a.kt)("h2",k({},{id:"driver"}),"Driver"),(0,a.kt)("p",null,"The driver section allows developers to select drivers for various responsibilities of a TouchGFX AL."),(0,a.kt)("h3",k({},{id:"application-tick-source"}),"Application Tick Source"),(0,a.kt)("p",null,"The application tick source for an application defines how to drive an application forward. The developer has the following options:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"LTDC"),' - If LTDC is selected as the interface the "Display" group the Application Tick Source can be "LTDC". This means that TouchGFX Generator will install a driver function (LTDC interrupt handler) in ',(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFXGeneratedHAL")," class that drives the application forward by calling ",(0,a.kt)("inlineCode",{parentName:"li"},"OSWrappers::signalVSync()"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Custom and FMC")," - In this case, the developer is required to implement a handler that drives the application forward by calling ",(0,a.kt)("inlineCode",{parentName:"li"},"OSWrappers::signalVSync()")," repeatedly.")),(0,a.kt)("h3",k({},{id:"graphics-accelerator"}),"Graphics Accelerator"),(0,a.kt)("p",null,"The developer has three options when it comes to graphics acceleration:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"None")," - The application uses only the CPU to render frames."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Chrom-ART (DMA2D)")," -\xa0The application uses the Chrom-ART chip when possible to move and blend pixels, freeing up CPU cycles. The driver is installed by TouchGFX Generator and does not require any action from the developer.")),(0,a.kt)("p",null,"The Chrom-ART (DMA2D) driver supplied by TouchGFX Generator supports two ways of receiving a TransferCompleteInterrupt."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Uses the STM32Cube HAL driver where it registers a callback funtion to the dma2d handle ",(0,a.kt)("inlineCode",{parentName:"li"},"hdma2d.XferCpltCallback"),"."),(0,a.kt)("li",{parentName:"ol"},"Uses the ",(0,a.kt)("inlineCode",{parentName:"li"},"DMA2D_IRQHandler()")," interrupt handler directly.")),(0,a.kt)("p",null,"Switching between these two is done by enabling or disabling the DMA2D global interrupt in the NVIC Settings in STM32CubeMX for DMA2D IP. Enabling the global interrupt generated code for option 1), disabling the global interrupt generates code for option 2)."),(0,a.kt)(o.Z,{mdxType:"Note"},(0,a.kt)("li",null,'When using global interrupt for DMA2D, ensure that the "IRQ handler" calls the "DMA2D HAL handler", this is default behaviour.'),(0,a.kt)("li",null,'If disabling "IRQ handler" and "Call HAL handler" for DMA2D while global interrupt is enabled will cause the registered callback to never be called.')),(0,a.kt)("h3",k({},{id:"real-time-operating-system"}),"Real-Time Operating System"),(0,a.kt)("p",null,"Developers can use any RTOS with TouchGFX (even No OS). As described in the Abstraction Layer Architecture the TouchGFX Engine uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"OSWrappers")," interface to synchronize its main event loop as well as framebuffer access with the users choice of RTOS. When developers select an operating system via TouchGFX Generator code will be generated to syncronize internally via primitives for the OS of choice. The operating system still has to be configured through STM32CubeMX to determine stack size, among other things."),(0,a.kt)("p",null,"FreeRTOS (CMSIS OS compliant) and AzureRTOS (For H7s only) can be configured directly from within STM32CubeMX and the TouchGFX Generator providing the user with generated code for both task definitions and TouchGFX RTOS driver. TouchGFX Generator can generate CMSIS V1 and CMSIS V2 compliant RTOS drivers which work with any CMSIS compliant RTOS, a driver for running bare metal without an operating system, and a native driver for ThreadX (Through the AzureRTOS X-Cube). In the case of No Operating Systemn developers cannot rely on STM32CubeMX for code generation of task definitions and this must be done in ",(0,a.kt)("em",{parentName:"p"},"user code"),"."),(0,a.kt)(o.Z,{mdxType:"Note"},"All TouchGFX Board Setups available from the designer run FreeRTOS."),(0,a.kt)("p",null,"The following figure shows these options available through the TouchGFX Generator."),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/driver-rtos-options-4-17.webp",mdxType:"Figure"},"RTOS driver options"),(0,a.kt)("p",null,'Concretely, in this image, The AzureRTOS X-CUBE has been enabled, allowing the selection of ThreadX and CMSIS RTOS V2 (ThreadX is CMSIS compliant). If FreeRTOS is enabled the "ThreadX" option is disabled. ThreadX can be enabled through the X-CUBE-AZRTOS-H7 (H7 only) pack.'),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/x-cube-azurertos.webp",width:"600",mdxType:"Figure"},"X-CUBE-AZRTOS Configuration"),(0,a.kt)("p",null,"The TouchGFX main loop is entered when calling the following function."),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{className:"language-cpp"}),"void\xa0MX_TouchGFX_Process(void);\n")),(0,a.kt)("p",null,"Developers are required to call this function in the task handler for the task they intend to run the TouchGFX application in. If the user configured a FeeRTOS task from STM32CubeMX called ",(0,a.kt)("inlineCode",{parentName:"p"},"DefaultTask")," then the following example shows how ",(0,a.kt)("inlineCode",{parentName:"p"},"MX_TouchGFX_Process()")," is called to start TouchGFX in the user code section of its task handler."),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{className:"language-cpp",metastring:"{4}","{4}":!0}),"void\xa0StartDefaultTask(void\xa0*argument)\n{\n\xa0\xa0/*\xa0USER\xa0CODE\xa0BEGIN\xa05\xa0*/\n  MX_TouchGFX_Process();\n\xa0\xa0/*\xa0USER\xa0CODE\xa0END\xa05\xa0*/\xa0\n}\n")),(0,a.kt)("p",null,"When FreeRTOS is enabled, STM32CubeMX will also generate a call to ",(0,a.kt)("inlineCode",{parentName:"p"},"osKernelStart();")," which starts the scheduler."),(0,a.kt)("h4",k({},{id:"other-cmsis-compliant-os"}),"Other CMSIS compliant OS"),(0,a.kt)("p",null,"When developers require a different CMSIS compliant OS than what STM32CubeMX can offer (FreeRTOS and ThreadX) he must perform RTOS configuration and task definition manually. Generally, the following manual steps are required:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Configure the RTOS"),(0,a.kt)("li",{parentName:"ol"},"Define a task to run TouchGFX (",(0,a.kt)("inlineCode",{parentName:"li"},"MX_TouchGFX_Process"),")"),(0,a.kt)("li",{parentName:"ol"},"Start the scheduler")),(0,a.kt)("p",null,"Here's an example of how to perform steps 2 and 3 for ThreadX, manually. Since STM32CubeMX cannot help with any configuration for operating systems it does not support everything must be done in the provided ",(0,a.kt)("em",{parentName:"p"},"user code sections")," to avoid code being overwritten. The following code shows pseudo code for the GUI task definition. Generally, any code that is not generated by STM32CubeMX should be placed in ",(0,a.kt)("em",{parentName:"p"},"user code sections")," that are scattered throughout the file ",(0,a.kt)("inlineCode",{parentName:"p"},"main.c"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{className:"language-cpp"}),'/* BEGIN USER CODE SECTION */\n#include "tx_api.h"\n\n#define GUI_THREAD_STACK_SIZE         1024\nTX_THREAD gui_thread;\nvoid    gui_thread_entry(ULONG thread_input); //Thread prototype\n/* END USER CODE SECTION */\n\nint main()\n{\n  /* BEGIN USER CODE SECTION - Choose an appropriate one from main.c */\n  /* Allocate the stack for gui thread  */\n  tx_byte_allocate(...);\n\n  /* Create the gui thread.  */\n  tx_thread_create(&gui_thread, "GUI Thread", gui_thread_entry, 0,\n              pointer, GUI_TASK_STACK_SIZE,\n              1, 1, TX_NO_TIME_SLICE, TX_AUTO_START);\n\n  /* END USER CODE SECTION*/\n')),(0,a.kt)("p",null,"Call ",(0,a.kt)("inlineCode",{parentName:"p"},"MX_TouchGFX_Process")," to start the TouchGFX Engine Main Loop inside the task handler."),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{className:"language-cpp"}),"/* BEGIN USER CODE SECTION */\nvoid gui_thread_entry(ULONG thread_input)\n{\n  MX_TouchGFX_Process();\n}\n/* END USER CODE SECTION*/\n")),(0,a.kt)("p",null,"Start the scheduler to start the GIU task and your TouchGFX Application."),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{className:"language-cpp"}),"/* BEGIN USER CODE SECTION */\ntx_kernel_enter();\n/* END USER CODE SECTION*/\n")),(0,a.kt)("h3",k({},{id:"additional-features"}),"Additional features"),(0,a.kt)("h4",k({},{id:"external-data-reader"}),"External Data Reader"),(0,a.kt)("p",null,"For the RGB565 Framebuffer Pixel Format touchgfx supports a so called ",(0,a.kt)("em",{parentName:"p"},"Data Reader")," interface that allows developers to read data directly from a non-memory-mapped serial flash instead of ",(0,a.kt)("a",k({parentName:"p"},{href:"../ui-development/touchgfx-engine-features/caching-bitmaps"}),"caching")," which comes at the cost of an additional buffer in memory. Please see the ",(0,a.kt)("a",k({parentName:"p"},{href:"../scenarios/using-serial-flash"}),"SerialFlash")," article for a example on how to implement a DataReader to retrieve application assets from a non-memory mapped flash chip."),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"Data Reader")," option is typically used for low cost solutions (e.g. STM32G0) that do not have enough memory for additional buffers. It cannot be enabled if DMA2D is also enabled."),(0,a.kt)("p",null,"Once ",(0,a.kt)("em",{parentName:"p"},"RGB565")," is selected as the Framebuffer Pixel Format, ",(0,a.kt)("em",{parentName:"p"},"Additional Features")," group becomes available."),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/additional-features-data-reader.webp",width:"520",noShadow:!0,mdxType:"Figure"},"Additional Features: Data Reader"),(0,a.kt)("p",null,"The following configurations can be made by the developer:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"External Data Reader"),": Enable or Disable the feature. Enabling will cause TouchGFX to retrieve data for assets directly through the generated interface. If disabled, developers are then required to ",(0,a.kt)("em",{parentName:"li"},"cache")," images to a buffer in memory instead."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"External Data Reader: Line Buffer Size"),": Creates two buffers for blending images or text into the framebuffer. Default value is one screen width*4 bytes to support full size images in ARGB8888 pixel format."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"External Data Reader: Minimum DMA transfer size"),": Set minimum required bytes to start a DMA transfer. If fewer bytes are requested, DMA will not be used.")),(0,a.kt)("p",null,"After generating code with ",(0,a.kt)("em",{parentName:"p"},"External Data Reader")," enabled, the following, additional files are created to support the retrieval of assets directly from a non-memory mapped flash."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFX/target/generated/TouchGFXGeneratedDataReader.cpp")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFX/target/generated/TouchGFXGeneratedDataReader.hpp")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFX/target/TouchGFXDataReader.cpp")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFX/target/TouchGFXDataReader.hpp"))),(0,a.kt)("p",null,"As usual, for code generated by TouchGFX Generator, ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXGeneratedDataReader")," is read-only and user modifications should be made inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXDataReader")," class. ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXGeneratedDataReader")," is of type ",(0,a.kt)("inlineCode",{parentName:"p"},"touchgfx::FlashDataReader"),"."),(0,a.kt)("p",null,"Modifications will be made to the following files to configure TouchGFX HAL to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"DataReader"),"."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFX/target/generated/TouchGFXConfiguration.cpp")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFX/target/generated/TouchGFXGeneratedHAL.cpp")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFX/target/generated/TouchGFXGeneratedHAL.hpp"))),(0,a.kt)(o.Z,{mdxType:"Note"},"The DataReader Additional Feature is only available if DMA2D and LTDC are disabled."),(0,a.kt)("h4",k({},{id:"8bit-ltdc-color-look-up-table"}),"8bit LTDC Color Look-up Table"),(0,a.kt)("p",null,"When the LTDC is configured to read the framebuffer in L8 format and TouchGFX renders in either ",(0,a.kt)("a",k({parentName:"p"},{href:"../../api/classes/classtouchgfx_1_1_l_c_d8bpp___a_b_g_r2222"}),"ABRG2222"),", ",(0,a.kt)("a",k({parentName:"p"},{href:"../../api/classes/classtouchgfx_1_1_l_c_d8bpp___a_r_g_b2222"}),"ARGB222"),", ",(0,a.kt)("a",k({parentName:"p"},{href:"../../api/classes/classtouchgfx_1_1_l_c_d8bpp___b_g_r_a2222"}),"BGRA2222"),", or ",(0,a.kt)("a",k({parentName:"p"},{href:"../../api/classes/classtouchgfx_1_1_l_c_d8bpp___r_g_b_a2222"}),"RGBA2222"),", TouchGFX Generator will provide a CLUT which is loaded into the LTDC during ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXHAL::initialize()"),". Please refer to the STM32 MCU reference manual for more details on usage of LTDC and CLUT."),(0,a.kt)("h2",k({},{id:"video-decoding"}),"Video Decoding"),(0,a.kt)("p",null,"The Video Decoding section allows developers to enhance the TouchGFX HAL with either hardware or software video decoding capabilities."),(0,a.kt)("p",null,"Video Decoding is only available with RGB565 (16bpp) and RGB888 (24bpp) framebuffer pixel formats. If neither of these formats are selected the Video Decoding section will not be available."),(0,a.kt)(o.Z,{mdxType:"Note"},"Not all MCUs support hardware video decoding."),(0,a.kt)("h3",k({},{id:"video-decoding-type"}),"Type"),(0,a.kt)("p",null,'By default the "Type" of video Decoding is disabled. If the required peripherals are not enabled in STM32CubeMX both "Software" and "Hardware" will be greyed out. Hover the mouse over the greyed out options the see which peripherals are required.'),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/video-dependecies-info-box.webp",width:"800",mdxType:"Figure"},'Info box showing Video Type dependencies for "Hardware"'),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Software"),' - If LIBJPEG is enabled under the Middleware section in STM32CubeMX the "Software" option can be selected and the software decoder will be generated. This means that TouchGFX Generator will generate a software MJPEG decoder.'),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Hardware"),' - If JPEG is enabled under the Multimedia section and a CMSIS compliant RTOS is selected in the TouchGFX Generator the "Hardware" option can be selected.')),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/video-decoding-options-4-18.webp",width:"800",mdxType:"Figure"},"Video decoding type options"),(0,a.kt)("p",null,'In the LIBJPEG settings the RGB ordering in the "RGB scanline format"-section has to be set to "BGR" instead of "RGB" for efficiency. The number of bytes per pixel must be set to 3.'),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/libjpeg-rgb-ordering.webp",width:"700",mdxType:"Figure"},"Required LIBJPEG RGB scanline format settings"),(0,a.kt)("p",null,"When working with hardware decoding the RGB format in the JPEG settings has to be the same as the display."),(0,a.kt)(i.Z,{mdxType:"FurtherReading"},"See section ",(0,a.kt)(c.Z,{to:"scenarios/scenarios-video-decoding",mdxType:"Link"},"Scenarios")," for concrete examples of code for different video decoding scenarios."),(0,a.kt)("h3",k({},{id:"video-decoding-number"}),"Concurrent videos"),(0,a.kt)("p",null,'The "Concurrent Videos" option is the largest amount of videos being decoded simultainously on the same screen in the GUI at any given time. If you only wish to decode one video on a screen the "Number of Videos" can be set to 1.'),(0,a.kt)("p",null,"A maximum of 4 videos can be decoded simultaneously."),(0,a.kt)("h3",k({},{id:"video-decoding-strategy"}),"Strategy"),(0,a.kt)("p",null,"The developer has three options when it comes to the video decoding strategy."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Direct to Framebuffer"),' - The video is decoded in the UI thread. It is slower than the other strategies. When working with hardware video decoding the "Direct to Framebuffer" option is unavailable.'),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Single Buffer")," - Video is decoded in a seperate task in a dedicated buffer. This buffer is allocated in internal memory."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Double Buffer")," - Video is decoded in a seperate task in two dedicated buffers for better performances at the cost of memory.")),(0,a.kt)("p",null,"When working with the single or double framebuffer strategy it is necessary to enable a CMSIS compliant OS."),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/video-rtos-requirement-info-box.webp",width:"700",mdxType:"Figure"},"Info box about CMSIS RTOS requirement"),(0,a.kt)(o.Z,{mdxType:"Note"},"Pay attention to the memory consumption when working with the double buffer strategy."),(0,a.kt)(i.Z,{mdxType:"FurtherReading"},"See section ",(0,a.kt)(c.Z,{to:"scenarios/scenarios-video-decoding",mdxType:"Link"},"Scenarios")," for a concrete example of configuring FreeRTOS for video decoding."),(0,a.kt)("h3",k({},{id:"decode-format"}),"Decode Format"),(0,a.kt)("p",null,"For Software decoding, developers can choose the pixel format of the RGB buffer regardless of the pixel format of the framebuffer. TouchGFX Generator generates code that allows ChromART to do pixel-format-conversion between the formats if they're different. Having the video decoding buffer in RGB565 allows developers to have a smaller memory footprint."),(0,a.kt)(r.Z,{noShadow:!0,imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/video-decoding-decode-format.webp",width:"700",mdxType:"Figure"},"Decode format"),(0,a.kt)("h3",k({},{id:"video-decoding-buffer-size"}),"Buffer size"),(0,a.kt)("p",null,"The buffer width and height settings must correspond to the largest video dimension in the application. The width must be divisible by 32."),(0,a.kt)("p",null,"The following code is the generated code in ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXGeneratedHAL.cpp"),' for an application using an RGB888 display with a 480*272 video and the "Single Buffer" video decoding strategy.'),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXGeneratedHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{className:"language-cpp"}),"\n#include <DedicatedBufferVideoController.hpp>\n#include <SoftwareMJPEGDecoder.hpp>\n\nuint32_t lineBuffer[480];\n\nSoftwareMJPEGDecoder mjpegdecoder1((uint8_t*)lineBuffer);\n\nuint32_t videoRGBBuffer[97920];\nDedicatedBufferController<1, 480, 272, 480*3U, Bitmap::RGB888> videoController;\n\n//Singleton Factory\nVideoController& VideoController::getInstance()\n{\n    return videoController;\n}\n\nvoid TouchGFXGeneratedHAL::initialize()\n{\n    HAL::initialize();\n    registerEventListener(*(Application::getInstance()));\n    setFrameBufferStartAddresses((void*)frameBuf, (void*)(frameBuf + sizeof(frameBuf) / (sizeof(uint32_t) * 2)), (void*)0);\n\n    /*\n     * Add software decoder to video controller\n     */\n    videoController.addDecoder(mjpegdecoder1, 0);\n\n    videoController.setRGBBuffer((uint8_t*)videoRGBBuffer, sizeof(videoRGBBuffer));\n}\n")),(0,a.kt)("h2",k({},{id:"generated-project"}),"Generated project"),(0,a.kt)("p",null,"TouchGFX works with (at least) the following IDEs when generating code using the ",(0,a.kt)("strong",{parentName:"p"},"Generate Code")," button in STM32CubeMX:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"EWARM"),(0,a.kt)("li",{parentName:"ol"},"MDK-ARM"),(0,a.kt)("li",{parentName:"ol"},"STM32CubeIDE")),(0,a.kt)("p",null,"For optimal project structure select the following options for project generation:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Application structure: ",(0,a.kt)("strong",{parentName:"li"},"Advanced")),(0,a.kt)("li",{parentName:"ul"},"Disable ",(0,a.kt)("strong",{parentName:"li"},"Generate under root")," (STM32CubeIDE only)")),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/project-manager.webp",noShadow:!1,mdxType:"Figure"},"Select Advanced application structure and deselect Generate under root"),(0,a.kt)("p",null,"STM32CubeMX will also generate a ",(0,a.kt)("em",{parentName:"p"},"TouchGFX")," folder with the following structure:"),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/folder-b.webp",noShadow:!1,mdxType:"Figure"},"TouchGFX folder structure"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("em",{parentName:"li"},"App")," folder which contains code to initialize and start TouchGFX."),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("em",{parentName:"li"},"target")," folder which contains read-only, generated code (inside generated/) and modifiable user classes (",(0,a.kt)("inlineCode",{parentName:"li"},"STM32TouchController.cpp"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFXGPIO.cpp")," and ",(0,a.kt)("inlineCode",{parentName:"li"},"TouchGFXHAL.cpp"),")"),(0,a.kt)("li",{parentName:"ul"},"The ",(0,a.kt)("em",{parentName:"li"},".part")," file which is opened using the TouchGFX Designer in order to create a full TouchGFX project complete with TouchGFX header files and libraries The part file contains relevant application information such as pixel format, and canvas dimensions that the designer uses when generating TouchGFX application code.")),(0,a.kt)("h2",k({},{id:"touchgfx-designer-project"}),"TouchGFX Designer Project"),(0,a.kt)("p",null,"The following code is an example of the contents of the ",(0,a.kt)("inlineCode",{parentName:"p"},".part")," file mentioned in the ",(0,a.kt)("a",k({parentName:"p"},{href:"#generated-code-architecture"}),"Generated Code Architecture")," section. The post-generate command, seen below, will update the project selected in STM32CubeMX (e.g. EWARM) when new files are created by the TouchGFX designer (e.g. new screens and assets)."),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{className:"language-json"}),'{\n "Application": {\n "Name": "my_project",\n "TouchGfxPath": "../Middlewares/ST/touchgfx",\n "AvailableColorDepths": [ 16 ],\n "AvailableLCDs":\n  {\n    "16": "LCD16bpp"\n },\n "AvailableResolutions" :\n [\n  {\n    "Width": 320,\n    "Height": 240\n  }\n ],\n "PostGenerateTargetCommand" : "touchgfx update_project --project-file=../my_project.ioc --platform=m7"\n },\n "Version": "4.13.0"\n}\n')),(0,a.kt)("p",null,"When opening the ",(0,a.kt)("em",{parentName:"p"},".part")," file with TouchGFX Designer developers are presented with the option to load a concrete UI or start from a blank template."),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/choose-ui-4-17.webp",noShadow:!1,mdxType:"Figure"},"Choose UI"),(0,a.kt)("p",null,"After pressing ",(0,a.kt)("em",{parentName:"p"},"Generate Code")," in TouchGFX Designer the structure of the TouchGFX folder now looks like the following. The following image shows a concrete example of a TouchGFX folder structure and highlights the files and folders that are new after generation."),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/designer-gen-code-4-17.webp",noShadow:!1,mdxType:"Figure"},"Generate Code"),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/post-designer-generation.webp",noShadow:!1,mdxType:"Figure"},"TouchGFX Folder Structure"),(0,a.kt)("p",null,"TouchGFX will detect the selected IDE from the .ioc STM32CubeMX file (For STM32CubeIDE, EWARM, MDK-ARM) and update the project file with new, generated files like files for screen definitions, image- and font assets."),(0,a.kt)("p",null,"At this point, developers can work interchangeably in STM32CubeMX, TouchGFX Designer and toolchain/IDE where:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"STM32CubeMX updates the IDE project with drivers"),(0,a.kt)("li",{parentName:"ul"},"STM32CubeMX updates the TouchGFX ",(0,a.kt)("em",{parentName:"li"},".part")," file with UI related changes that are instantly picked up by the designer"),(0,a.kt)("li",{parentName:"ul"},"STM32CubeMX generates HAL code (TouchGFX/target/generated/) based on TouchGFX Generator Configuration necessary for TouchGFX to work on a specific platform."),(0,a.kt)("li",{parentName:"ul"},"The TouchGFX designer updates the project with generated code.")),(0,a.kt)(o.Z,{mdxType:"Note"},'For Dual-Core projects, having enabled TouchGFX for a specific context, the TouchGFX project will usually be located in a dedicated folder for that context, e.g. "CM4/TouchGFX" or "CM7/TouchGFX".'),(0,a.kt)("h2",k({},{id:"modifying-generated-behavior"}),"Modifying Generated Behavior"),(0,a.kt)("p",null,"It important to know that, due to the class hierarchy of the HAL, users can override HAL configuration or behavior that was generated by STM32CubeMX. In the example below, developers can modify the ",(0,a.kt)("inlineCode",{parentName:"p"},"initialize")," function to configure TouchGFX additionally or to modify an existing configuration set in ",(0,a.kt)("inlineCode",{parentName:"p"},"TouchGFXGeneratedHAL"),"."),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"TouchGFXHAL.cpp"),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{className:"language-cpp"}),"void TouchGFXHAL::initialize()\n{\n    // Calling parent implementation of initialize().\n    //\n    // To overwrite the generated implementation, omit call to parent function\n    // and implemented needed functionality here.\n    // Please note, HAL::initialize() must be called to initialize the framework.\n\n    TouchGFXGeneratedHAL::initialize();\n\n    //Overriding configurations\n    hal.lockDMAToFrontPorch(true);\n    hal.setFingerSize(4);\n    hal....\n}\n")),(0,a.kt)("h2",k({},{id:"upgrading-projects"}),"Upgrading Projects"),(0,a.kt)("p",null,"TouchGFX Generator parameters are stored in .ioc files (STM32CubeMX project). When a new version of TouchGFX Generator is released the parameters of the old version may be incompatible with the new version and may require migration."),(0,a.kt)("p",null,"Since STM32CubeMX does not support upgrading between X-CUBE versions the upgrade is automatically performed by TouchGFX Designer when ",(0,a.kt)("em",{parentName:"p"},"Generate Code")," is pressed due to the following command in the ",(0,a.kt)("inlineCode",{parentName:"p"},"PostGenerateTargetCommand")," section of the ",(0,a.kt)("inlineCode",{parentName:"p"},".touchgfx")," file."),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},".touchgfx"),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{}),'"PostGenerateTargetCommand" : "touchgfx update_project --project-file=../upgrade.ioc --platform=m7"\n')),(0,a.kt)("p",null,"The command will read the ",(0,a.kt)("inlineCode",{parentName:"p"},".ioc")," file and update the parameters to fit the current version of X-CUBE-TOUCHGFX. Below is an example of running the script (X-CUBE-TOUCHGFX 4.14.0) by hand on an .ioc file created with X-CUBE-TOUCHGFX 4.13.0."),(0,a.kt)(l.Z,{mdxType:"CodeHeader"},"Upgrade example using STM32F746 DISCO TouchGFX Board Setup from 4.13.0 to 4.14.0"),(0,a.kt)("pre",null,(0,a.kt)("code",k({parentName:"pre"},{}),"$ touchgfx update_project --project-file=../STM32F746G_DISCO.ioc\n  TouchGFX Generator 4.13.0 found\n  Creating backup of ../STM32F746G_DISCO.ioc as ../backup_STM32F746G_DISCO.ioc\n  Performing upgrade 4.13.0 -> 4.14.0 ... OK\n")),(0,a.kt)("p",null,"Opening the updated project with STM32CubeMX prompts the user to install the version of X-CUBE-TOUCHGFX that is represented by the .ioc file (if not already installed). Clicking ",(0,a.kt)("em",{parentName:"p"},"Download now")," will download and install X-Cube-TouchGFX-4.14.0."),(0,a.kt)(r.Z,{imageSource:"/img/development/touchgfx-hal-development/touchgfx-generator/cubemx-additional-software-manager-settings-missing-x-cube-touchgfx-4.14.0.webp",noShadow:!1,mdxType:"Figure"},"Additional Software Component Missing: TouchGFX Generator 4.14.0"),(0,a.kt)("p",null,"All configurations in TouchGFX Generator will be kept during the upgrade procedure and a backup of the .ioc file will be placed beside the original on prepended with ",(0,a.kt)("inlineCode",{parentName:"p"},"backup_"),"."),(0,a.kt)(o.Z,{mdxType:"Note"},"To use the new features provided by TouchGFX Generator, ",(0,a.kt)("i",null,"Generate Code")," must be performed in STM32CubeMX."),(0,a.kt)(d.Z,{mdxType:"Caution"},"If upgrading X-CUBE-TOUCHGFX through STM32CubeMX for an existing TouchGFX Project and the upgrade process is not run by TouchGFX Designer, TouchGFX Generator parameters will be reset to default since they are applicable to a different version."))}C.isMDXComponent=!0}}]);